{{$an:=.Name.Fmt}}{{$attr:=.}}
{{if .ID}}const {{$an}}Attr zcl.AttrID = {{.ID.Uint}}
func ({{$an}}) ID() zcl.AttrID { return {{$an}}Attr }
func ({{$an}}) Readable() bool { return {{if .CanRead}}true{{else}}false{{end}} }
func ({{$an}}) Writable() bool { return {{if .CanWrite}}true{{else}}false{{end}} }
func ({{$an}}) Reportable() bool { return {{if .Report}}true{{else}}false{{end}} }
func ({{$an}}) SceneIndex() int { return {{if .Scene}}{{.Scene}}{{else}}-1{{end}} }
{{end}}
func ({{$an}}) Name() string { return "{{.Name}}" }

{{.Desc.Comment .Name.Fmt}}{{ if eq .Type "local" }}
type {{.Name.Fmt}} struct { {{range .StructAttr}}
    {{.Desc.Comment .ArgNameFmt}}{{.ArgNameFmt}} {{if .Name}}{{.Name.Fmt}}{{else}}{{.Type.RealType}}{{end}}{{end}}
}
func (a *{{$an}}) TypeID() zcl.TypeID { return zcl.TypeID(76) } // struct
func (a *{{$an}}) Value() zcl.Val { return a }
func (a {{$an}}) MarshalZcl() ([]byte, error) { {{if .StructAttr}}
    var data []byte
    var tmp []byte
    tmp2 := uint32(0)
    var err error
    _ = tmp2
    _ = err
    {{range .StructAttr}}
        {{if .Cond}}{{condDesc .ArgNameFmt .Cond}}if {{joinCond $attr.StructAttr .Cond}} { {{else}} { {{end}}{{if .Marshal}}
        {{.Marshal}}{{else}}
        if tmp, err = a.{{.ArgNameFmt}}.MarshalZcl(); err != nil {
        return nil, err
        }{{end}}
        data = append(data, tmp...)
    } {{end}}
    return data, nil {{ else }}
    return nil, nil {{ end }}
}

func (a *{{$an}}) UnmarshalZcl(b []byte) ([]byte, error) { {{if .StructAttr}}
    var err error
    tmp2 := uint32(0)
    _ = tmp2
    _ = err
    {{range .StructAttr}}
        {{if .Cond}}{{condDesc .ArgNameFmt .Cond}}if {{joinCond $attr.StructAttr .Cond}} { {{end}}{{if .Unmarshal}}
        {{.Unmarshal}}{{else}}if b, err = {{if .Name}}(&a.{{.ArgNameFmt}}){{else}}new(zcl.{{.Type.Type}}){{end}}.UnmarshalZcl(b); err != nil {
        return b, err
        }{{end}}
        {{if .Cond}} } {{end}}
    {{end}}
{{ end }}return b, nil
}

func (a *{{$an}}) SetValue(v zcl.Val) error {
    if nv, ok := v.(*{{$an}}); ok {
        *a = *nv
        return nil
    }
    return zcl.ErrNotImpl
}

func (a *{{$an}}) String() string {
    return zcl.Sprintf(
        "{{.Name.Fmt}}{" + zcl.StrJoin([]string{ {{range .StructAttr}}{{if .Name}}
            "{{.ArgNameFmt}}(%v)",{{end}}{{end}}
        }, " ")+"}", {{range .StructAttr}}{{if .Name}}
        a.{{.ArgNameFmt}},{{end}}{{end}}
    )
}

{{else}}type {{.Name.Fmt}} {{ if .ArrayType}}[]*{{.ArrayType.RealType}}{{else}}{{.Type.RealType}}{{end}}

func (a *{{$an}}) TypeID() zcl.TypeID { return new({{.Type.RealType}}).TypeID() }
func (a *{{$an}}) Value() zcl.Val { return a }

{{ if .ArrayType}}
func ({{$an}}) ArrayTypeID() zcl.TypeID { return new({{.ArrayType.RealType}}).TypeID() }

func (a *{{$an}}) ArrayValues() (o []{{.ArrayType.Native}}) {
    for _, v := range *a {
        o = append(o, {{if eq .ArrayType.RealType .ArrayType.Native}}*v{{else}}{{.ArrayType.Native}}(*v){{end}})
    }
    return o
}

func (a *{{$an}}) SetValues(val []{{.ArrayType.Native}}) error {
    *a = []*{{.ArrayType.RealType}}{}
    return a.AddValues(val...)
}

func (a *{{$an}}) AddValues(val ...{{.ArrayType.Native}}) error {
    for _, v := range val {
        nv := {{if eq .ArrayType.RealType .ArrayType.Native}}v{{else}}{{.ArrayType.RealType}}(v){{end}}
        *a = append(*a, &nv)
    }
    return nil
}

func (a {{$an}}) MarshalZcl() ([]byte, error) {
    var vars []zcl.Val
    for _, v := range a {
        vars = append(vars, v)
    }
    return zcl.ArrayNoTypeMarshalZcl("sloc", vars)
}

func (a *{{$an}}) UnmarshalZcl(b []byte) ([]byte, error) {
    *a = []*{{.ArrayType.RealType}}{}
    return zcl.UnmarshalList("sloc", b, func() zcl.Val {
        nv := new({{.ArrayType.RealType}})
        *a = append(*a, nv)
        return nv
    })
}

func (a *{{$an}}) SetValue(v zcl.Val) error {
    if nv, ok := v.(*{{$an}}); ok {
        *a = *nv
        return nil
    }
    return zcl.ErrInvalidType
}


func (a {{$an}}) String() string {
    var s []string
    for _, v := range a {
        s = append(s, zcl.Sprintf("%v", v))
    }
    return "["+zcl.StrJoin(s, ",")+"]"
}

{{ else }}
func (a {{$an}}) MarshalZcl() ([]byte, error) { return {{.Type.RealType}}(a).MarshalZcl() }

func (a *{{$an}}) UnmarshalZcl(b []byte) ([]byte, error) {
    nt := new({{.Type.RealType}})
    br, err := nt.UnmarshalZcl(b)
    *a = {{.Name.Fmt}}(*nt)
    return br, err
}

func (a {{$an}}) MarshalJSON() ([]byte, error) {
    return zcl.ToJson({{.Type.RealType}}(a))
}

func (a *{{$an}}) UnmarshalJSON(b []byte) error {
    v := new({{.Type.RealType}})
    if err := zcl.ParseJson(b, v); err != nil {
        return err
    }
    *a = {{$an}}(*v)
    return nil
}

func (a *{{$an}}) SetValue(v zcl.Val) error {
    if nv, ok := v.(*{{.Type.RealType}}); ok {
        *a = {{$an}}(*nv)
        return nil
    }
    return zcl.ErrInvalidType
}

func (a {{$an}}) String() string { {{if .Values}}switch a { {{range $vk,$vv := .Values}}
        case {{$vk}}: return "{{$vv}}"{{end}}
    }{{end}}{{if .Bits}}
    var bstr []string
    bits := zcl.BitmapList(a[:])
    for _, bit := range bits {
        switch bit { {{range $vk,$vv := .Bits}}
            case {{$vk}}: bstr = append(bstr, "{{$vv}}") {{end}}
            default: bstr = append(bstr, zcl.Sprintf("Unknown(%d)", bit))
        }
    }
    return zcl.StrJoin(bstr, ", "){{else if eq .Unit "s"}}
    return zcl.Seconds.Format(float64(a){{if .Multiplier}}/{{.Multiplier}}{{end}}){{else if .Unit}}
    return zcl.{{.Unit}}.Format(float64(a){{if .Multiplier}}/{{.Multiplier}}{{end}}){{else}}
    return zcl.Sprintf("%v", {{.Type.RealType}}(a)){{end}}
}

{{range $vk,$vv := .Bits}}
func (a {{$an}}) Is{{$vv.Fmt}}() bool { return zcl.BitmapTest([]byte(a[:]), {{$vk}}) }{{end}}{{range $vk,$vv := .Bits}}
func (a *{{$an}}) Set{{$vv.Fmt}}(b bool) { copy((*a)[:], zcl.BitmapSet([]byte((*a)[:]), {{$vk}}, b)) } {{end}}

{{if .Bits}}func({{$an}}) MultiOptions() []zcl.Option {
    return []zcl.Option{ {{range $vk,$vv := .Bits}}
        {Value: {{$vk}}, Name: "{{$vv}}"},{{end}}
    }
}{{end}}

{{range $vk,$vv := .Values}}
func (a {{$an}}) Is{{$vv.Fmt}}() bool { return a == {{$vk}} }{{end}}{{range $vk,$vv := .Values}}
func (a *{{$an}}) Set{{$vv.Fmt}}() { *a = {{$vk}} }{{end}}

{{if .Values}}func({{$an}}) SingleOptions() []zcl.Option {
    return []zcl.Option{ {{range $vk,$vv := .Values}}
        {Value: {{$vk}}, Name: "{{$vv}}"},{{end}}
    }
}{{end}}
{{end}}

{{ end }}
