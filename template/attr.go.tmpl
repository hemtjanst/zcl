{{$an:=.Name.Fmt}}{{.Desc.Comment .Name.Fmt}}type {{.Name.Fmt}} zcl.{{.Type.Type}}
{{if .ID}}const {{$an}}Attr zcl.AttrID = {{.ID.Uint}}
func ({{$an}}) ID() zcl.AttrID { return {{$an}}Attr }
func ({{$an}}) Readable() bool { return {{if .CanRead}}true{{else}}false{{end}} }
func ({{$an}}) Writable() bool { return {{if .CanWrite}}true{{else}}false{{end}} }
func ({{$an}}) Reportable() bool { return {{if .Report}}true{{else}}false{{end}} }
func ({{$an}}) SceneIndex() int { return {{if .Scene}}{{.Scene}}{{else}}-1{{end}} }
{{end}}
func ({{$an}}) Name() string { return "{{.Name}}" }
func (a *{{$an}}) TypeID() zcl.TypeID { return zcl.{{.Type.Type}}(*a).ID() }
func (a *{{$an}}) Value() zcl.Val { return a }

{{ if .ArrayType}}
func ({{$an}}) ArrayTypeID() zcl.TypeID { return new(zcl.{{.ArrayType.Type}}).ID() }

{{ if eq .ArrayType "struct" }}

{{ else }}
func (a *{{$an}}) ArrayValues() (o []{{.ArrayType.Native}}) {
    for _, v := range a.Content {
        if vv, ok := v.(*zcl.{{.ArrayType.Type}}); ok {
            o = append(o, {{.ArrayType.Native}}(*vv))
        }
    }
    return o
}

func (a *{{$an}}) SetValues(val []{{.ArrayType.Native}}) error {
    a.Type = a.ArrayTypeID()
    a.Content = []zcl.Val{}
    return a.AddValues(val...)
}

func (a *{{$an}}) AddValues(val ...{{.ArrayType.Native}}) error {
    a.Type = a.ArrayTypeID()
    for _, v := range val {
        nv := zcl.{{.ArrayType.Type}}(v)
        a.Content = append(a.Content, &nv)
    }
    return nil
}
{{ end }}

func (a *{{$an}}) MarshalZcl() ([]byte, error) { {{if .MarshalNoType}}
    return zcl.ArrayNoTypeMarshalZcl("sloc", a.Content){{ else }}
    a.Type = a.ArrayTypeID()
    return zcl.{{.Type.Type}}(*a).MarshalZcl(){{end}}
}

func (a *{{$an}}) UnmarshalZcl(b []byte) ([]byte, error) { {{if .MarshalNoType}}
    var err error
    a.Content, b, err = zcl.ArrayNoTypeUnmarshalZcl("sloc", b, a.ArrayTypeID())
    return b, err{{ else }}
    nt := &zcl.{{.Type.Type}}{Type: a.ArrayTypeID()}
    br, err := nt.UnmarshalZcl(b)
    *a = {{.Name.Fmt}}(*nt)
    return br, err{{end}}
}
{{ else }}
func (a {{$an}}) MarshalZcl() ([]byte, error) { return zcl.{{.Type.Type}}(a).MarshalZcl() }

func (a *{{$an}}) UnmarshalZcl(b []byte) ([]byte, error) {
    nt := new(zcl.{{.Type.Type}})
    br, err := nt.UnmarshalZcl(b)
    *a = {{.Name.Fmt}}(*nt)
    return br, err
}
{{ end }}

func (a *{{$an}}) SetValue(v zcl.Val) error {
    if nv, ok := v.(*zcl.{{.Type.Type}}); ok {
        *a = {{$an}}(*nv)
        return nil
    }
    return zcl.ErrInvalidType
}

func (a {{$an}}) String() string { {{if .Values}}switch a { {{range $vk,$vv := .Values}}
        case {{$vk}}: return "{{$vv}}"{{end}}
    }{{end}}{{if .Bits}}
    var bstr []string
    bits := zcl.BitmapList(a[:])
    for _, bit := range bits {
        switch bit { {{range $vk,$vv := .Bits}}
            case {{$vk}}: bstr = append(bstr, "{{$vv}}") {{end}}
            default: bstr = append(bstr, zcl.Sprintf("Unknown(%d)", bit))
        }
    }
    return zcl.StrJoin(bstr, ", "){{else if eq .Unit "s"}}
    return zcl.Seconds.Format(float64(a){{if .Multiplier}}/{{.Multiplier}}{{end}}){{else if .Unit}}
    return zcl.{{.Unit}}.Format(float64(a){{if .Multiplier}}/{{.Multiplier}}{{end}}){{else}}
    return zcl.Sprintf("%v", zcl.{{.Type.Type}}(a)){{end}}
}

{{range $vk,$vv := .Bits}}
func (a {{$an}}) Is{{$vv.Fmt}}() bool { return zcl.BitmapTest([]byte(a[:]), {{$vk}}) }{{end}}{{range $vk,$vv := .Bits}}
func (a *{{$an}}) Set{{$vv.Fmt}}(b bool) { copy((*a)[:], zcl.BitmapSet([]byte((*a)[:]), {{$vk}}, b)) } {{end}}

{{if .Bits}}func({{$an}}) MultiOptions() []zcl.Option {
    return []zcl.Option{ {{range $vk,$vv := .Bits}}
        {Value: {{$vk}}, Name: "{{$vv}}"},{{end}}
    }
}{{end}}

{{range $vk,$vv := .Values}}
func (a {{$an}}) Is{{$vv.Fmt}}() bool { return a == {{$vk}} }{{end}}{{range $vk,$vv := .Values}}
func (a *{{$an}}) Set{{$vv.Fmt}}() { *a = {{$vk}} }{{end}}

{{if .Values}}func({{$an}}) SingleOptions() []zcl.Option {
    return []zcl.Option{ {{range $vk,$vv := .Values}}
        {Value: {{$vk}}, Name: "{{$vv}}"},{{end}}
    }
}{{end}}